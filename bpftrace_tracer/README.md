# bpftrace based tracer

This is a code for a custom [bpftrace](https://github.com/bpftrace/bpftrace)-based tracer I built to debug an extremely latency
sensitive hang. `bpftrace` was the only existing tool that could enable this among all other different approaches I tried.

This codebase is essentially a **single use throwaway code not applicable to solving any other problem**, however, it can
be useful as a basis for building similar solution to a different problem.

## Components

### gen-bt.py

`gen-bt.py` is a generator to produce actual `bpftrace` script. I found it's easier and more reliable to generate a quite
large and intertwined `bpftrace` script from parts, rather than writing it manually. It is less error-prone, simplifies
changing common parts and lets produce a script with more guarantees of correctness than writing it manually.

Running `python3 ./gen-bt.py` will produce `./bpft.bt` in the same directory. Note that this `bpft.bt` script is highly
optimized to produce a bare necessary minimal output as going verbose too much changes relative thread latencies and
this effectively conceals the hang. Even with the current version the hang disappears much more frequently, and one might
have to rerun the tracing several time to get a hang. But at least it works.

The easiest way is to couple the script generation and execution/tracing in one line:

```bash
rm ./log.log ; python3 ./gen-bt.py && bpftrace ./bpft.bt -o ./log.log
```

and then in a different terminal one could launch the software to examine. `bpftrace` execution could be stopped anytime with `ctrl+c`.

In approaching a different problem I highly suggest prototype initial ideas with separate custom `bpftrace` scripts
and once it settles to work correctly, update the main script/generator.

### gdb-sym2.py

`gdb-sym2.py` parses the log file obtained after running `bptrace` with the script generated by `gen-bt.py` and produces
a human readable thread specific text log and a set of perfetto based `.pftrace` trace files
(requires `pip install perfetto`).

```bash
python3 ./gdb-sym2.py ./log.log > log.txt
```

The `.txt` log it produces is useful for manual inspection and to verify correctness of perfetto traces (always use only
https://magic-trace.org to view the traces! https://ui.perfetto.dev/ is buggy and renders some slices length incorrectly).
All 3 `.pftrace` files are identical with the only exception of how individual slices are cross-linked. Those having
`_comm_` in name are linked by a communicator object used, `_device_` - by a physical device identifier used, found
generally in `comm_cudaDev` field, `_stream_`  - are linked by the hip stream identifier. `magic-trace` file name
suffix highlights the necessity of https://magic-trace.org/ to view the traces.

It's easier to run the parser/converter for all gathered logs in the dir and pack the results to an archive with a one-liner

```bash
rm ./t.tar.gz ; for flog in ./*.log; do python3 ./gdb-sym2.py $flog > $flog.txt ; done && tar -zcvf ./t.tar.gz ./*.log ./*.pftrace ./*.txt
```

Initially, this script was thought of as a script to execute inside `GDB` debugging session (hence the `gdb-` prefix in the
filename) to fetch symbolic information that `bpftrace` failed to deliver. However, since I was able to find a workaround for this
issue, `GDB` session is no longer needed, and the script can run separately perfectly fine. However, the code still contains
functions related to a code pointer to symbol resolution, and basically everything still works under assumption that the
parser reads raw code addresses from the log instead of symbolic information (hence there's a seemingly redundant symbol
translation phase). While not necessary at this point, these codes could still be useful, for example,
to find code locations that called the API of interest (minor changes to the tracer and the parser would still be needed
for that).

## Notes on `bpftrace`

While it's already super powerfull, `bpftrace` is still kind of an experimental tool with some associated instability
and bugs, so sometimes one might need to try several workarounds to implement an idea, since the most obvious might not work, or
work incorrectly. But have said this precaution words, I want to highlight that in general it works extremely well and
the support its team provides to users is just excellent even by a paid product standards.

Versions of the `bpftrace` available in corresponding distribution repositories are usually quite old and might lack useful
features (especially on Ubuntu, which typically lacks way behind a corresponding upstream Debian distro). However,
`bpftrace` team also provide binary releases available from a `Releases` page of the repo.

My `bpft.bt` script worked with v0.24.1, a corresponding binary of which can be downloaded directly from its [release link](https://github.com/bpftrace/bpftrace/releases/download/v0.24.1/bpftrace).

**NOTE**: there are no guarantees that the generated `bpft.bt` will work with any other `bpftrace` version, however,
changes required likely won't be huge. It'll probably work with versions that didn't diverge far from 0.24.1.

**NOTE 2**: versions `0.23 - 0.24.1` had [a bug](https://github.com/bpftrace/bpftrace/discussions/4807) where `pid`
keyword returned a thread identifier `tid`, and vice-versa `tid` returned a process identier `pid`, when traced code
runs in a Linux namespace (such as when it runs in a docker container). The mitigation is to use `tid(init)` form to
query a current thread id instead of generic unqualified `tid` form. This form should likely remain stable and workable
across many bpftrace versions. The bug fix was merged into the `master` and will likely be released as a part of the
next release following `v0.24.1`.
